require("dotenv").config();

import { uploadToGCloudBucket } from "./portfolioFunctions";
import { readBBGBlot, readIB, readBBE } from "./mufgOperations";
import { getTradeDateYearTrades, formatDateReadable, convertExcelDateToJSDate, formateDateNomura, getSettlementDateYearNomura, generateRandomString } from "./common";
import { getSettlementDateYear, readIBEblot } from "./portfolioFunctions";
import { formatDateVconFile } from "./common";
import { getSecurityInPortfolioWithoutLocation } from "./graphApiConnect";
import { formatTradeDate } from "./common";
const xlsx = require("xlsx");
const { PassThrough } = require("stream");
const { MongoClient, ServerApiVersion } = require("mongodb");

const uri = "mongodb+srv://alaa:" + process.env.MONGODBPASSWORD + "@atlascluster.zpfpywq.mongodb.net/?retryWrites=true&w=majority";
const axios = require("axios");
const client = new MongoClient(uri, {
  serverApi: {
    version: ServerApiVersion.v1,
    strict: false,
    deprecationErrors: true,
  },
});

function extractValuesVcon(lines: any) {
  let variables = [
    "Broker Code",
    "Status",
    "Buy/Sell",
    "Quantity",
    "Issue",
    "Benchmark",
    "Price",
    "Yield",
    "Principal",
    "Trade Date",
    "Acc Int",
    "Settle Date",
    "Net",
    "Spread",
    "Entry Time",
    "Customer",
    "Seq No",
    "Account",
    "User Name",
    "Audit Trail",
    "Broker Name",
    "Accrued Interest",
    "Application",
    "Benchmark Discount",
    "Benchmark Price",
    "Benchmark Yield",
    "Client Side",
    "Currency Symbol",
    "Cusip",
    "Dealer Notes",
    "Dealer Pricing Number",
    "Discount Rate",
    "End Date",
    "Factor Label",
    "Futures client broker",
    "Futures dealer broker",
    "ISIN",
    "Price (Decimal)",
    "Primary Security ID",
    "Rate",
    "Swap Sequence Number",
    "Trading System Ticket #",
    "Transaction Cost",
    "Unit Traded",
  ];
  // Prepare the variable pattern, escape special characters
  const varPattern = variables.map((v: any) => v.trim().replace(/[.*+\?^{}()|[\]\\]/g, "\\&")).join("|");

  let values: any = {};

  lines.forEach((line: any) => {
    // Split the line into segments based on the variable names
    const segments = line.split(new RegExp(`(${varPattern})`));

    for (let i = 1; i < segments.length; i += 2) {
      let varName = segments[i].trim();
      let value = "";

      if (i + 1 < segments.length) {
        // Slice the value from the segment, remove leading ':'
        value = segments[i + 1].split(":")[1]?.trim() || "";
        // console.log(value)
      }
      // console.log(varName, value)

      values[varName] = value;
    }
  });

  return values;
}
function parseArray(arr: any) {
  let obj: any = {};
  for (let i = 0; i < arr.length; i++) {
    let splitString = arr[i].split(":");
    if (splitString.length === 2) {
      let key = splitString[0].trim();
      let value = splitString[1].trim();
      obj[key] = value;
    }
  }
  return obj;
}
export function renderVcon(emailContent: string) {
  const start = "Broker Code";
  const end = "** TICKET GENERATED BY BLOOMBERG **";

  // Find the start and end indices of the relevant content
  const startIndex = emailContent.indexOf(start);
  const endIndex = emailContent.indexOf(end) + end.length;

  // Extract the relevant content
  const relevantContent = emailContent.slice(startIndex, endIndex);

  let lines = relevantContent.split("\n");
  lines.pop();
  lines.pop();
  lines.pop();
  lines = lines.filter((line) => line !== "------------------------------------------------------------------------------");
  lines = lines.filter((line) => line !== "");

  let vcon: any = {};
  let main: any = lines.slice(0, 10);
  let secondary: any = lines.slice(11, -1);
  // console.log(secondary)

  let firstParams = extractValuesVcon(main);
  let secondParams = parseArray(secondary);
  vcon = { ...firstParams, ...secondParams };

  return vcon;
}

export async function uploadArrayAndReturnFilePath(vcons: any, pathName: string) {
  let binaryWS = xlsx.utils.json_to_sheet(vcons);

  // Create a new Workbook
  var wb = xlsx.utils.book_new();

  // Name your sheet
  xlsx.utils.book_append_sheet(wb, binaryWS, "Binary values");
  // export your excel
  const stream = new PassThrough();
  const buffer = xlsx.write(wb, { type: "buffer", bookType: "xlsx" });
  let randomString = generateRandomString(6);
  let fileName = `after-excel/${pathName}_${randomString}.xlsx`;

  uploadToGCloudBucket(buffer, process.env.BUCKET, fileName).then().catch(console.error);

  return fileName;
}

export function formatNomuraEBlot(vcons: any) {
  let nomuraEBlot = [];
  for (let index = 0; index < vcons.length; index++) {
    let vcon = vcons[index];
    let tradeDateFormated = formateDateNomura(vcon["Trade Date"]);
    let settlementDateFormated = getSettlementDateYearNomura(vcon["Trade Date"], vcon["Settle Date"]);
    let object: any = {};
    object["Transaction-Type-Indicator"] = "BS";
    object["Client-Ref"] = "";
    object["Shaped-Trade-Ref"] = "";
    object["Account-Number"] = "CPB10728";
    object["Trade-Version"] = "NEW";
    object["Trade-Date"] = tradeDateFormated;
    object["Settlement-Date"] = settlementDateFormated;
    object["BS-Indicator"] = vcon["Buy/Sell"];
    object["Security-Indicator-Type"] = "IS";
    object["Security-Val"] = vcon["ISIN"];
    object["Security-Description"] = vcon["Issue"];
    object["Issue-Currency"] = vcon["Application"];
    object["Broker"] = vcon["Broker Name"];
    object["Quantity"] = parseInt(vcon["Quantity"].replace(/,/g, ""));
    object["Price"] = vcon["Price (Decimal)"];
    object["Commission-Type"];
    object["Commission-Value"] = "0";
    object["Tax	Proceeds"];
    object["Proceeds-Currency"];
    object["Interest"] = vcon["Accrued Interest"];
    object["Prefigured-Indicator"];
    nomuraEBlot.push(object);
  }
  return nomuraEBlot;
}

export async function getTriadaTrades(tradeType: any) {
  const database = client.db("trades");
  const reportCollection = await database.collection(`${tradeType}`).find().toArray();
  return reportCollection;
}

export async function formatTriadaBlot(files: any) {
  let bbbData = [],
    ibData = [],
    bbeData = [];
  for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {
    let file = files[fileIndex];
    if (file["fieldname"] == "BBB") {
      bbbData = await readBBGBlot(file["filename"]);
    } else if (file["fieldname"] == "IB") {
      let url = "https://storage.googleapis.com/capital-trade-396911.appspot.com" + file["filename"];
      ibData = await readIBEblot(url);
    } else if (file["fieldname"] == "BBE") {
      bbeData = await readBBE(file["filename"]);
    }
  }
  let blot = [];
  let counter = 1;
  for (let index = 0; index < bbbData.length; index++) {
    let obj: any = {};
    let trade = bbbData[index];
    if (trade["Status"] == "Accepted") {
      let settlementDate = getSettlementDateYear(convertExcelDateToJSDate(trade["Trade Date"]), convertExcelDateToJSDate(trade["Settle Date"]));
      obj["Location"] = trade["Location"];
      obj["Date"] = getTradeDateYearTrades(convertExcelDateToJSDate(trade["Trade Date"]));
      obj["Time"] = trade["Entry Time"].split(" ")[1] + ":00";
      obj["B/S"] = trade["Buy/Sell"];
      obj["Bond/CDS"] = trade["Issue"];
      obj["Price"] = trade["Price (Decimal)"];
      obj["Notionol Amount"] = parseFloat(trade["Quantity"].replace(/,/g, ""));
      obj["Trader"] = "JM";
      obj["Counter Party"] = trade["Broker Code"];
      obj["Settlement Date"] = getTradeDateYearTrades(settlementDate);
      obj["Settlement Amount"] = parseFloat(trade["Net"].replace(/,/g, ""));
      blot.push(obj);
      counter++;
    }
  }

  for (let index2 = 0; index2 < ibData.length; index2++) {
    let trade = ibData[index2];

    let obj: any = {};

    obj["Location"] = trade["Location"];
    obj["Date"] = trade["Date/Time"];
    obj["Time"] = trade["Trade Time"];
    obj["B/S"] = parseFloat(trade["Quantity"]) > 0 ? "B" : "S";
    obj["Bond/CDS"] = trade["Symbol"];
    obj["Price"] = trade["T Price"];
    obj["Notionol Amount"] = parseFloat(trade["Quantity"]);
    obj["Trader"] = "JM";
    obj["Counter Party"] = "IB";
    obj["Settlement Date"] = trade["Trade Date"];
    obj["Settlement Amount"] = trade["Notional Value"];
    blot.push(obj);
    counter++;
  }

  for (let index3 = 0; index3 < bbeData.length; index3++) {
    let obj: any = {};
    let trade = bbeData[index3];

    obj["Location"] = trade["Location"];
    obj["Date"] = trade["Trade Date"];
    obj["Time"] = "";
    obj["B/S"] = trade["Buy/Sell"] == "Sell" ? "S" : "B";
    obj["Bond/CDS"] = trade["Security"];
    obj["Price"] = trade["Price"];
    obj["Notionol Amount"] = parseFloat(trade["Quantity"]);
    obj["Trader"] = "JM";
    obj["Counter Party"] = "EMSX";
    obj["Settlement Date"] = trade["Trade Date"];
    obj["Settlement Amount"] = parseFloat(trade["Quantity"]);
    blot.push(obj);
    counter++;
  }

  return blot;
}
function extractValuesFx(text: any) {
  let lines = text.split("\n");
  let output: any = {};

  lines.forEach((line: any) => {
    let colonIndex = line.indexOf(":");
    let key, value;
    if (colonIndex !== -1) {
      key = line.slice(0, colonIndex).trim();
      value = line.slice(colonIndex + 1).trim();
      output[key] = value;
    }
  });
  output = formatFxTrades(output);
  return output;
}
export function formatIbTrades(data: any, ibTrades: any, portfolio: any) {
  let trades = [];
  try {
    let count = ibTrades.length + 1;
    for (let index = 0; index < data.length; index++) {
      let trade = data[index];
      let id;
      let object: any = {};
      if (trade["Header"] == "Data") {
        let tradeDate = convertExcelDateToJSDate(data[index]["Date/Time"]);
        trade["Trade Date"] = formatTradeDate(tradeDate);
        trade["Settle Date"] = formatTradeDate(tradeDate);

        let existingTrade = null;
        for (let ibIndex = 0; ibIndex < ibTrades.length; ibIndex++) {
          let ibTrade = ibTrades[ibIndex];
          if (trade["Symbol"] == ibTrade["Symbol"] && trade["Quantity"] == ibTrade["Quantity"] && trade["Trade Date"] == ibTrade["Trade Date"] && trade["Settle Date"] == ibTrade["Settle Date"] && trade["T. Price"] == ibTrade["T Price"] && trade["C. Price"] == ibTrade["C Price"]) {
            existingTrade = ibTrade;
          }
        }
        let identifier = trade["Symbol"];
        let securityInPortfolioLocation = getSecurityInPortfolioWithoutLocation(portfolio, identifier);

        if (existingTrade) {
          id = existingTrade["Triada Trade Id"];
        } else {
          id = `Triada-IB-${trade["Trade Date"]}-${count}`;
          count++;
        }
        object["Currency"] = trade["Currency"];
        object["Symbol"] = trade["Symbol"] + " IB";
        object["Quantity"] = trade["Quantity"];
        object["T Price"] = trade["T. Price"];
        object["C Price"] = data[index]["C. Price"];
        object["Notional Value"] = trade["Notional Value"];
        object["Comm/Fee"] = trade["Comm/Fee"];
        object["Basis"] = trade["Basis"];
        object["Realized P/L"] = trade["Realized P/L"];
        object["MTM P/L"] = trade["MTM P/L"];
        object["Code"] = trade["Code"];
        object["Trade Date"] = trade["Trade Date"];
        object["Settle Date"] = trade["Settle Date"];
        object["Triada Trade Id"] = id;
        object["Location"] = securityInPortfolioLocation && securityInPortfolioLocation != "" ? securityInPortfolioLocation : trade["Location"].toUpperCase();
        // object["Original Face"] = table API
        trades.push(object);
      }
    }
  } catch (error) {
    return { error: error };
  }
  return trades;
}
function formatFxTrades(object: any) {
  let titles = Object.keys(object);
  let formattedObject: any = {};
  for (let index = 0; index < titles.length; index++) {
    let title = titles[index];
    if (title == "Symbol") {
      let buyCurrency = object[title].split("/")[0];
      let sellCurrency = object[title].split("/")[1];
      formattedObject["Buy Currency"] = buyCurrency;
      formattedObject["Sell Currency"] = sellCurrency;
    } else if (title == "Timestamp") {
      formattedObject["Trade Date"] = formatDateReadable(object[title]);
    } else if (title == "Value Date") {
      formattedObject["Settle Date"] = formatDateReadable(object[title]);
    } else if (title == "Amount 1") {
      formattedObject["Buy Amount"] = parseFloat(object[title].split(" ")[1].replace(/,/g, ""));
    } else if (title == "Amount 2") {
      formattedObject["Sell Amount"] = parseFloat(object[title].split(" ")[1].replace(/,/g, ""));
    } else {
      formattedObject[title] = object[title];
    }
  }
  return formattedObject;
}
export function renderFx(emailContent: string) {
  const start = "User";
  const end = "This e-mail";

  // Find the start and end indices of the relevant content
  const startIndex = emailContent.indexOf(start);
  const endIndex = emailContent.indexOf(end) + end.length;

  // Extract the relevant content
  const relevantContent = emailContent.slice(startIndex, endIndex);

  let fxTrade: any = {};

  let firstParams = extractValuesFx(relevantContent);

  fxTrade = { ...firstParams };

  return fxTrade;
}

export function formatEmsxTrades(data: any, emsxTrades: any, portfolio: any) {
  let trades = [];
  try {
    let count = emsxTrades.length + 1;
    for (let index = 0; index < data.length; index++) {
      let trade = data[index];
      let id;
      let object: any = {};

      let existingTrade: any = null;

      for (let emsxIndex = 0; emsxIndex < emsxTrades.length; emsxIndex++) {
        let emsxTrade = emsxTrades[emsxIndex];
        if (trade["Trade Date"] == emsxTrade["Create Time (As of)"] && trade["Security"] == emsxTrade["Security"] && trade["Buy/Sell"] == emsxTrade["Side"] && trade["Quantity"] == emsxTrade["Qty"]) {
          existingTrade = emsxIndex;
        }
      }
      let tradeDate = convertExcelDateToJSDate(data[index]["Create Time (As of)"]);
      trade["Trade Date"] = formatTradeDate(tradeDate);
      trade["Settle Date"] = formatTradeDate(tradeDate);
      let identifier = trade["Security"];
      let securityInPortfolioLocation = getSecurityInPortfolioWithoutLocation(portfolio, identifier);

      if (existingTrade) {
        id = existingTrade["Triada Trade Id"];
      } else {
        id = `Triada-EMSX-${trade["Trade Date"]}-${count}`;
        count++;
      }
      object["Status"] = trade["Status"];
      object["Buy/Sell"] = trade["Side"];
      object["Security"] = trade["Security"];
      object["Quantity"] = trade["FillQty"];
      object["Price"] = trade["LmtPr"];
      object["Trade Date"] = trade["Trade Date"];
      object["Settle Date"] = trade["Settle Date"];
      object["Triada Trade Id"] = id;
      object["Location"] = securityInPortfolioLocation;
      trades.push(object);
    }
  } catch (error) {
    return { error: error };
  }
  return trades;
}
export async function readEmsxRawExcel(path: string) {
  try {
    const response = await axios.get(path, { responseType: "arraybuffer" });

    /* Parse the data */
    const workbook = xlsx.read(response.data, { type: "buffer" });

    /* Get first worksheet */
    const worksheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[worksheetName];

    /* Convert worksheet to JSON */
    // const jsonData = xlsx.utils.sheet_to_json(worksheet, { defval: ''});

    // Read data

    const headers = xlsx.utils.sheet_to_json(worksheet, { header: 1 });
    const headersFormat = ["News", "Create Time (As of)", "Status", "Security", "Side", "Qty", "LmtPr", "TIF", "FillQty", "AvgPr", "% Filled", "Working Qty", "Idle", "Data Export Restricted", "Data Export Restricted", "VWAP", "Data Export Restricted", "Last", "Bid", "Ask", "Volume", "%20d ADV"];
    const arraysAreEqual = headersFormat.every((value, index) => (value === headers[0][index + 2] ? true : false));
    if (!arraysAreEqual) {
      return {
        error: "Incompatible format, please upload emsx e-blot xlsx/csv file",
      };
    } else {
      let data = xlsx.utils.sheet_to_json(worksheet, {
        defval: "",
        range: "D1:X300",
      });

      return data;
    }
  } catch (error) {
    return { error: error };
  }
}
export function formatVconToNomuraBulkUpload(data: any) {}
