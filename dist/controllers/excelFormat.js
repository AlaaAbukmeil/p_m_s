"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatEmsxTrades = exports.renderFx = exports.formatIbTrades = exports.formatCentralizedRawFiles = exports.getTriadaTrades = exports.renderVcon = void 0;
require("dotenv").config();
const mufgOperations_1 = require("./operations/mufgOperations");
const common_1 = require("./common");
const tools_1 = require("./reports/tools");
const graphApiConnect_1 = require("./graphApiConnect");
const readExcel_1 = require("./operations/readExcel");
const auth_1 = require("./auth");
const xlsx = require("xlsx");
const { PassThrough } = require("stream");
const { v4: uuidv4 } = require("uuid");
const axios = require("axios");
function extractValuesVcon(lines) {
    let variables = [
        "Broker Code",
        "Status",
        "Buy/Sell",
        "Quantity",
        "Issue",
        "Benchmark",
        "Price",
        "Yield",
        "Principal",
        "Trade Date",
        "Acc Int",
        "Settle Date",
        "Net",
        "Spread",
        "Entry Time",
        "Customer",
        "Seq No",
        "Account",
        "User Name",
        "Audit Trail",
        "Broker Name",
        "Accrued Interest",
        "Application",
        "Benchmark Discount",
        "Benchmark Price",
        "Benchmark Yield",
        "Client Side",
        "Currency Symbol",
        "Cusip",
        "Dealer Notes",
        "Dealer Pricing Number",
        "Discount Rate",
        "End Date",
        "Factor Label",
        "Futures client broker",
        "Futures dealer broker",
        "ISIN",
        "Price (Decimal)",
        "Primary Security ID",
        "Rate",
        "Swap Sequence Number",
        "Trading System Ticket #",
        "Transaction Cost",
        "Unit Traded",
    ];
    // Prepare the variable pattern, escape special characters
    const varPattern = variables.map((v) => v.trim().replace(/[.*+\?^{}()|[\]\\]/g, "\\&")).join("|");
    let values = {};
    lines.forEach((line) => {
        var _a;
        // Split the line into segments based on the variable names
        const segments = line.split(new RegExp(`(${varPattern})`));
        for (let i = 1; i < segments.length; i += 2) {
            let varName = segments[i].trim();
            let value = "";
            if (i + 1 < segments.length) {
                // Slice the value from the segment, remove leading ':'
                value = ((_a = segments[i + 1].split(":")[1]) === null || _a === void 0 ? void 0 : _a.trim()) || "";
            }
            values[varName] = value;
        }
    });
    return values;
}
function parseArray(arr) {
    let obj = {};
    for (let i = 0; i < arr.length; i++) {
        let splitString = arr[i].split(":");
        if (splitString.length === 2) {
            let key = splitString[0].trim();
            let value = splitString[1].trim();
            obj[key] = value;
        }
    }
    return obj;
}
function renderVcon(emailContent) {
    const start = "Broker Code";
    const end = "** TICKET GENERATED BY BLOOMBERG **";
    // Find the start and end indices of the relevant content
    const startIndex = emailContent.indexOf(start);
    const endIndex = emailContent.indexOf(end) + end.length;
    // Extract the relevant content
    const relevantContent = emailContent.slice(startIndex, endIndex);
    let lines = relevantContent.split("\n");
    lines.pop();
    lines.pop();
    lines.pop();
    lines = lines.filter((line) => line !== "------------------------------------------------------------------------------");
    lines = lines.filter((line) => line !== "");
    let vcon = {};
    let main = lines.slice(0, 10);
    let secondary = lines.slice(11, -1);
    let firstParams = extractValuesVcon(main);
    let secondParams = parseArray(secondary);
    vcon = { ...firstParams, ...secondParams };
    return vcon;
}
exports.renderVcon = renderVcon;
async function getTriadaTrades(tradeType, fromTimestamp = 0, toTimestamp = 0) {
    const database = auth_1.client.db("trades_v_2");
    let options = [];
    // If both timestamps are provided, use them to filter the results
    if (fromTimestamp !== null && toTimestamp !== null) {
        options.push({ timestamp: { $gte: fromTimestamp, $lte: toTimestamp } });
        // If only fromTimestamp is provided
    }
    else if (fromTimestamp !== null) {
        options.push({ timestamp: { $gte: fromTimestamp } });
        // If only toTimestamp is provided
    }
    else if (toTimestamp !== null) {
        options.push({ timestamp: { $lte: toTimestamp } });
    }
    let query = {};
    // If there are any timestamp options, use them in the query
    if (options.length > 0) {
        query.$and = options;
    }
    let reportCollection = await database.collection(`${tradeType}`).find(query).toArray();
    if (fromTimestamp && toTimestamp) {
        reportCollection = reportCollection.filter((trade, index) => {
            // Include trade if tradeDate property does not exist
            // Convert tradeDate to a timestamp if necessary
            const tradeDateTimestamp = new Date(trade["Trade Date"]).getTime();
            // Check if tradeDate falls within the specified range
            return tradeDateTimestamp >= fromTimestamp && tradeDateTimestamp <= toTimestamp;
        });
    }
    for (let index = 0; index < reportCollection.length; index++) {
        let trade = reportCollection[index];
        trade["Trade App Status"] = "uploaded_to_app";
        trade["BB Ticker"] = trade["BB Ticker"] ? trade["BB Ticker"] : trade["Issue"];
        trade["Notional Amount"] = trade["Notional Amount"] && parseFloat(trade["Notional Amount"]) != 0 ? trade["Notional Amount"] : trade["Quantity"];
        delete trade["_id"];
        delete trade["Quantity"];
        delete trade["Issue"];
        delete trade["timestamp"];
    }
    return reportCollection;
}
exports.getTriadaTrades = getTriadaTrades;
async function formatCentralizedRawFiles(files, bbbData, vconTrades, ibTrades, emsxTrades) {
    let ibData = [], bbeData = [];
    for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {
        let file = files[fileIndex];
        if (file["fieldname"] == "BBB") {
            bbbData = await (0, mufgOperations_1.readBBGBlot)(file["filename"]);
            if (bbbData.error) {
                return bbbData;
            }
        }
        else if (file["fieldname"] == "IB") {
            let url = common_1.bucket + file["filename"];
            ibData = await (0, readExcel_1.readIBEblot)(url);
            if (ibData.error) {
                return ibData;
            }
        }
        else if (file["fieldname"] == "BBE") {
            let url = common_1.bucket + file["filename"];
            bbeData = await (0, readExcel_1.readEmsxEBlot)(url);
            if (bbeData.error) {
                return bbeData;
            }
        }
    }
    let blot_vcons = vconTrades.map(({ "Edit Note": _, "Updated Notional": __, ...rest }) => rest);
    let blot_ib = ibTrades.map(({ "Edit Note": _, "Updated Notional": __, ...rest }) => rest);
    let blot_emsx = emsxTrades.map(({ "Edit Note": _, "Updated Notional": __, ...rest }) => rest);
    let blot = [];
    let counter = 1;
    let bbbCurrency = {
        $: "USD",
        A$: "AUD",
        "€": "EUR",
        "£": "GBP",
        SGD: "SGD",
    };
    let centralizedBlotterHeader = ["B/S", "BB Ticker", "Location", "Trade Date", "Trade Time", "Settle Date", "Price", "Notional Amount", "Settlement Amount", "Principal", "Counter Party", "Triada Trade Id", "Seq No", "ISIN", "Cuisp", "Currency", "Yield", "Accrued Interest", "Original Face", "Comm/Fee", "Trade Type", "Trade App Status"];
    // vcons already checking if duplicate trade and removes it. ib and emsx no. ib trades to be implement with their API
    for (let index = 0; index < bbbData.length; index++) {
        let obj = {};
        let trade = bbbData[index];
        if (trade["Status"] == "Accepted") {
            let settlementDate = (0, tools_1.getSettlementDateYear)((0, common_1.convertExcelDateToJSDate)(trade["Trade Date"]), (0, common_1.convertExcelDateToJSDate)(trade["Settle Date"]));
            obj["B/S"] = trade["Buy/Sell"];
            obj["BB Ticker"] = trade["BB Ticker"];
            obj["Location"] = trade["Location"].trim();
            obj["Trade Date"] = (0, common_1.getTradeDateYearTrades)((0, common_1.convertExcelDateToJSDate)(trade["Trade Date"]));
            obj["Trade Time"] = trade["Entry Time"];
            obj["Settle Date"] = (0, common_1.getTradeDateYearTrades)(settlementDate);
            obj["Price"] = trade["Price (Decimal)"];
            obj["Notional Amount"] = parseFloat(trade["Notional Amount"].replace(/,/g, ""));
            obj["Settlement Amount"] = parseFloat(trade["Net"].replace(/,/g, ""));
            obj["Principal"] = parseFloat(trade["Principal"].replace(/,/g, ""));
            obj["Counter Party"] = trade["Broker Code"];
            obj["Triada Trade Id"] = trade["Triada Trade Id"];
            obj["Seq No"] = trade["Seq No"];
            obj["ISIN"] = trade["ISIN"];
            obj["Cuisp"] = trade["Cusip"];
            obj["Currency"] = bbbCurrency[trade["Currency Symbol"]];
            obj["Yield"] = trade["Yield"];
            obj["Accrued Interest"] = trade["Accrued Interest"];
            obj["Original Face"] = "1000";
            obj["Comm/Fee"] = "";
            obj["Trade Type"] = "vcon";
            obj["Trade App Status"] = trade["Trade App Status"];
            blot_vcons.push(obj);
            counter++;
        }
    }
    blot_vcons.sort((a, b) => new Date(a["Trade Date"]).getTime() - new Date(b["Trade Date"]).getTime());
    for (let index2 = 0; index2 < ibData.length; index2++) {
        let trade = ibData[index2];
        if (blot_ib.filter((ibTrade) => ibTrade["Triada Trade Id"] == trade["Triada Trade Id"])) {
            let obj = {};
            let originalFace = Math.abs(trade["Notional Value"] / trade["T Price"] / trade["Notional Amount"]);
            obj["B/S"] = parseFloat(trade["Notional Amount"]) > 0 ? "B" : "S";
            obj["BB Ticker"] = trade["Symbol"];
            obj["Location"] = trade["Location"].trim();
            obj["Trade Date"] = trade["Trade Date"];
            obj["Trade Time"] = trade["Trade Date Time"];
            obj["Settle Date"] = trade["Trade Date"];
            obj["Price"] = trade["T Price"];
            obj["Notional Amount"] = Math.abs(parseFloat(trade["Notional Amount"])) * originalFace;
            obj["Settlement Amount"] = Math.abs(trade["Notional Value"]);
            obj["Principal"] = Math.abs(trade["T Price"] * trade["Notional Amount"] * originalFace);
            obj["Counter Party"] = "IB";
            obj["Triada Trade Id"] = trade["Triada Trade Id"];
            obj["Seq No"] = "";
            obj["ISIN"] = "";
            obj["Cuisp"] = "";
            obj["Currency"] = "USD";
            obj["Yield"] = "";
            obj["Accrued Interest"] = "";
            obj["Original Face"] = originalFace;
            obj["Comm/Fee"] = trade["Comm/Fee"];
            obj["Trade Type"] = "ib";
            obj["Trade App Status"] = trade["Trade App Status"];
            blot_ib.push(obj);
            counter++;
        }
    }
    blot_ib.sort((a, b) => new Date(a["Trade Date"]).getTime() - new Date(b["Trade Date"]).getTime());
    for (let index3 = 0; index3 < bbeData.length; index3++) {
        let obj = {};
        let trade = bbeData[index3];
        if (blot_emsx.filter((emsxTrade) => emsxTrade["Triada Trade Id"] == trade["Triada Trade Id"])) {
            obj["B/S"] = trade["Buy/Sell"] == "Sell" ? "S" : "B";
            obj["BB Ticker"] = trade["Security"];
            obj["Location"] = trade["Location"].trim();
            obj["Trade Date"] = trade["Trade Date"];
            obj["Trade Time"] = "";
            obj["Settle Date"] = trade["Trade Date"];
            obj["Price"] = trade["Price"];
            obj["Notional Amount"] = parseFloat(trade["Notional Amount"]);
            obj["Settlement Amount"] = trade["Net"];
            obj["Principal"] = trade["Net"] * trade["Price"];
            obj["Counter Party"] = "EMSX";
            obj["Triada Trade Id"] = trade["Triada Trade Id"];
            obj["Seq No"] = "";
            obj["ISIN"] = "";
            obj["Cuisp"] = "";
            obj["Currency"] = "HKD";
            obj["Yield"] = "";
            obj["Accrued Interest"] = "";
            obj["Original Face"] = "1000";
            obj["Comm/Fee"] = "";
            obj["Trade Type"] = "emsx";
            obj["Trade App Status"] = trade["Trade App Status"];
            blot_emsx.push(obj);
            counter++;
        }
    }
    blot_emsx.sort((a, b) => new Date(a["Trade Date"]).getTime() - new Date(b["Trade Date"]).getTime());
    blot = [...blot_vcons, ...blot_ib, ...blot_emsx];
    if (blot.length > 0) {
        let formattedObject = {};
        centralizedBlotterHeader.forEach((title) => {
            // If the original object has the key, add it to the formatted object
            if (blot[0].hasOwnProperty(title)) {
                formattedObject[title] = blot[0][title];
            }
        });
        blot[0] = formattedObject;
        return blot;
    }
    else {
        return [];
    }
}
exports.formatCentralizedRawFiles = formatCentralizedRawFiles;
function extractValuesFx(text) {
    let lines = text.split("\n");
    let output = {};
    lines.forEach((line) => {
        let colonIndex = line.indexOf(":");
        let key, value;
        if (colonIndex !== -1) {
            key = line.slice(0, colonIndex).trim();
            value = line.slice(colonIndex + 1).trim();
            output[key] = value;
        }
    });
    output = formatFxTrades(output);
    return output;
}
function formatIbTrades(data, ibTrades, portfolio) {
    if (data.error) {
        return data;
    }
    let trades = [];
    try {
        for (let index = 0; index < data.length; index++) {
            let trade = data[index];
            let id;
            let object = {};
            if (trade["Header"] == "Data") {
                let tradeDate = (0, common_1.convertExcelDateToJSDate)(data[index]["Date/Time"]);
                let tradeDateTime = (0, common_1.convertExcelDateToJSDateTime)(data[index]["Date/Time"]);
                let trade_status = "new";
                trade["Trade Date"] = (0, common_1.formatDateUS)(tradeDate);
                trade["Settle Date"] = (0, common_1.formatDateUS)(tradeDate);
                trade["Symbol"] += " IB";
                let existingTrade = null;
                for (let ibIndex = 0; ibIndex < ibTrades.length; ibIndex++) {
                    let ibTrade = ibTrades[ibIndex];
                    if (trade["Symbol"] == ibTrade["BB Ticker"] && trade["Trade Date"] == ibTrade["Trade Date"] && Math.abs(ibTrade["Settlement Amount"]) == Math.abs(trade["Notional Value"])) {
                        existingTrade = ibTrade;
                    }
                }
                let identifier = trade["Symbol"];
                let securityInPortfolioLocation = (0, graphApiConnect_1.getSecurityInPortfolioWithoutLocationForVcon)(portfolio, identifier);
                if (existingTrade) {
                    id = existingTrade["Triada Trade Id"];
                    trade_status = "uploaded_to_app";
                }
                else {
                    id = uuidv4();
                }
                object["Currency"] = trade["Currency"];
                object["Symbol"] = trade["Symbol"];
                // ib file has as quantity
                object["Notional Amount"] = trade["Quantity"];
                object["T Price"] = trade["T. Price"];
                object["C Price"] = data[index]["C. Price"];
                object["Notional Value"] = trade["Notional Value"];
                object["Comm/Fee"] = trade["Comm/Fee"];
                object["Basis"] = trade["Basis"];
                object["Realized P/L"] = trade["Realized P/L"];
                object["MTM P/L"] = trade["MTM P/L"];
                object["Code"] = trade["Code"];
                object["Trade Date"] = trade["Trade Date"];
                object["Trade Date Time"] = tradeDateTime;
                object["Settle Date"] = trade["Settle Date"];
                object["Triada Trade Id"] = id;
                object["Location"] = securityInPortfolioLocation && securityInPortfolioLocation != "" ? securityInPortfolioLocation : trade["Location"];
                object["Trade App Status"] = trade_status;
                trades.push(object);
            }
        }
    }
    catch (error) {
        return { error: error };
    }
    return trades;
}
exports.formatIbTrades = formatIbTrades;
function formatFxTrades(object) {
    let titles = Object.keys(object);
    let formattedObject = {};
    for (let index = 0; index < titles.length; index++) {
        let title = titles[index];
        if (title == "Symbol") {
            let buyCurrency = object[title].split("/")[0];
            let sellCurrency = object[title].split("/")[1];
            formattedObject["Buy Currency"] = buyCurrency;
            formattedObject["Sell Currency"] = sellCurrency;
        }
        else if (title == "Timestamp") {
            formattedObject["Trade Date"] = (0, common_1.formatDateUS)(object[title]);
        }
        else if (title == "Value Date") {
            formattedObject["Settle Date"] = (0, common_1.formatDateUS)(object[title]);
        }
        else if (title == "Amount 1") {
            formattedObject["Buy Amount"] = parseFloat(object[title].split(" ")[1].replace(/,/g, ""));
        }
        else if (title == "Amount 2") {
            formattedObject["Sell Amount"] = parseFloat(object[title].split(" ")[1].replace(/,/g, ""));
        }
        else {
            formattedObject[title] = object[title];
        }
    }
    return formattedObject;
}
function renderFx(emailContent) {
    const start = "User";
    const end = "This e-mail";
    // Find the start and end indices of the relevant content
    const startIndex = emailContent.indexOf(start);
    const endIndex = emailContent.indexOf(end) + end.length;
    // Extract the relevant content
    const relevantContent = emailContent.slice(startIndex, endIndex);
    let fxTrade = {};
    let firstParams = extractValuesFx(relevantContent);
    fxTrade = { ...firstParams };
    return fxTrade;
}
exports.renderFx = renderFx;
function formatEmsxTrades(data, emsxTrades, portfolio) {
    if (data.error) {
        return data;
    }
    let trades = [];
    try {
        for (let index = 0; index < data.length; index++) {
            let trade = data[index];
            let id;
            let object = {};
            let existingTrade = null;
            let tradeDate = !trade["Create Time (As of)"].includes("/") ? (0, common_1.formatDateUS)(new Date()) : (0, common_1.formatDateUS)((0, common_1.convertExcelDateToJSDate)(trade["Create Time (As of)"]));
            let tradeType = trade["Side"] == "Sell" ? "S" : "B";
            for (let emsxIndex = 0; emsxIndex < emsxTrades.length; emsxIndex++) {
                let emsxTrade = emsxTrades[emsxIndex];
                // net because previous trade counted quantity as fill quantity
                if (tradeDate == emsxTrade["Trade Date"] && trade["Security"] == emsxTrade["BB Ticker"] && tradeType == emsxTrade["B/S"] && trade["FillQty"] == emsxTrade["Settlement Amount"]) {
                    existingTrade = emsxTrade;
                }
            }
            trade["Trade Date"] = tradeDate;
            trade["Trade Date Time"] = tradeDate;
            let identifier = trade["Security"];
            let securityInPortfolioLocation = (0, graphApiConnect_1.getSecurityInPortfolioWithoutLocationForVcon)(portfolio, identifier);
            let trade_status = "new";
            if (existingTrade) {
                id = existingTrade["Triada Trade Id"];
                trade_status = "uploaded_to_app";
            }
            else {
                id = uuidv4();
            }
            object["Status"] = trade["Status"];
            object["Buy/Sell"] = trade["Side"];
            object["Security"] = trade["Security"];
            object["Notional Amount"] = trade["Qty"];
            object["Net"] = trade["FillQty"];
            object["Price"] = trade["LmtPr"];
            object["Trade Date"] = trade["Trade Date"];
            object["Settle Date"] = trade["Trade Date"];
            object["Triada Trade Id"] = id;
            object["Location"] = securityInPortfolioLocation;
            object["Trade App Status"] = trade_status;
            trades.push(object);
        }
    }
    catch (error) {
        return { error: error };
    }
    return trades;
}
exports.formatEmsxTrades = formatEmsxTrades;
